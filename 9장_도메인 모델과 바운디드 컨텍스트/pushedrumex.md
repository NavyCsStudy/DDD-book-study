# 도메인 모델과 바운디드 컨텍스트

## 9.1 도메인 모델과 경계
- 한 개의 도메인 모델로 여러 하위 도메인을 모두 표현할 경우, 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.
- 하위 도메인마다 같은 용어라도 의미와 지칭하는 용어가 다름
  - ex) 회원
    - 회원 도메인에서느 '회원'
    - 주문 도메인에서는 '주문자'
    - 배송 도메인에서는 '보내는 사람'

- 따라서 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야한다.
- 모델은 특정 컨텍스트 하에 완전한 의미를 갖는다.
- 바운디드 컨텍스트 : 도메인 모델에서 구분되는 경계를 갖는 컨텍스트

## 9.2 바운디드 컨텍스트
- 바운디드 컨텍스트는 모델의 경계를 결정
- 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖음
- 상황에 따라 하위 도메인과 바운디드 컨텍스트가 1:1이 아닐 수도 있음 
  - 주문 하위 도메인에 '주문 바운디드 컨텍스트', '결제 금액 계산 바운디드 컨텍스트' 존재
  - 카탈로그 하위 도메인과 재고 하위 도메인이 '상품 바운디드 컨텍스트'에서 구현
- 한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 구현해야함
  - 이렇게 하면 물리적인 바운디드 컨텍스트는 한 개이더라도 하위 도메인마다 논리적은 바운디드 컨텍스트를 갖는 효과를 낼 수 있음
- 바운디드 컨텍스트는 구현하는 하위 도메인에 알맞은 모델을 포함
  - ex) 회원의 Member는 애그리거트 루트지만 주문 바운디드 컨텍스트에서는 Orderer 인 밸류임

## 9.3 바운디드 컨텍스트 구현
- 바운디드 컨텍스트는 도메인 모델 뿐만 아니라 표현 영역, 응용 서비스, 인프라스트럭처 영역, DB테이블을 포함
- 바운디드 컨텍스트를 도메인 주도로 개발할 필요가 없음. 즉, 표현 - 응용 서비스 - 도메인 - 인프라 - DBMS 구조로 개발할 필요 없음
  - ex) 리뷰 바운디드 컨텍스트는 도메인 로직을 갖지 않음
    - 표현 - 서비스 - DAO - DBMS
- 한 바운디드 컨텍스트에서 두 방식을 사용할 수도 있음
  - ex) CQRS 패턴 : 상태를 변경하는 명령 기능과 조회하는 쿼리 기능을 구분
- 각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있음
  - ex) 웹 MVC는 스프링 MVC를 사용, 리포리터리 구현 기술로는 JPA 하이버네이트를 사용
- 바운디드 컨텍스트는 UI 뿐만 아니라 REST API를 사용하여 JSON을 응답할 수 있음

## 9.4 바운디드 컨텍스트 간 통합
- ex) 기존의 카탈로그 하위 도메인에 개인화 추천 기능을 도입
- 카탈로그 하위 도메인에 추천 기능을 위한 바운디드 컨텍스트가 추가
- 통합이 필요한 기능 : 사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여줌
- 카탈로그 시스템은 추천 시스템으로부터 데이터를 받아와서 카탈로그 도메인 모델을 사용하여 추천 상품을 표현
- 도메인 서비스를 통해 상품 추천 기능을 표현
```java
// 외부 시스템과의 연동과 외부 시스템의 모델과 현재 도메인 모델간의 변환을 처리
public interface ProductRecommendationService {
    List<Product> getRecommendationsOf(Productld id);
}
```
- 도메인 서비스(ProductRecommendationService)의 구현체는 인프라스트럭처 영역에 위치
- ex) ProductRecommendationService 를 구현한 RecSystemClient
  ```java
  public class RecSystemClient implements ProductRecommendationService {
      private ProductRepository productRepository;
  
      @Override
      public List<Product> getRecommendationsOf(Productld id) {
          List<RecommendationItem> items = getRecItems(id.getVal니e());
          return toProducts(items);
      }
  
      private List<RecommendationItem> getRecItems(String itemld) {
          // externalRecClient는 외부 추천 시스템을 위한 클라이언트라고 가정
          return externalRecClient.getRecs(itemld);
      }
  }
  ```
  - RecommendationItem : 추천 시스템에서 사용하는 도메인 모델
  - toProducts() 메서드를 통해 카탈로그 도메인 모델로 변환
- 메시지큐를 사용하여 간접적으로 통합하는 방법도 존재
  - 이 경우 메시징 큐에 담을 데이터의 구조 협의가 필요

## 9.5 바운디드 컨텍스트 간 관계
- 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺음
- 하류 컴포넌트인 카탈로그 컨텍스트는 상류 컴포넌트인 추천 컨텍스트가 제공하는 데이터와 기능에 의존
- 카탈로그는 추천 바운디트 컨텍스트가 제공하는 REST API를 호출하여 추천 상품 데이터를 얻음
- 상류 컴포넌ㄴ트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 공개 -> 공개 호스트 서비스
- 상류 컴포넌트는 자신의 컨텍스트의 도메인 모델을 따르기 때문에, 하류 컴포넌트는 자신의 도메인 모델에 영향을 주지 않도록 보호해 주는 완충 지대를 만들어야함
  - ex) RecSystemClient 는 두 바운디드 컨텍스트 간의 모델 변환을 처리
- 두 바운디드 컨텍스트에서 같은 모델을 공유하는 경우도 있음 -> `공유 커널`
- 두 바운디드 컨텍스트를 통합하지 않는 `독립 방식` 
  - 독립 방식을 사용할 경우 컨텍스트 간의 통합은 수동으로 하거나 중간에 통합해주는 별도의 시스템을 만들어야함

## 9.6 컨텍스트 맵
- 컨텍스트 맵 : 바운디드 컨텍스트 간의 관계를 표시한 다이어그램
- 컨텍스트 맵은 시스템의 저네 구조를 보여줌
- OHS(오픈 호스트 서비스) : 외부 시스템이 이 컨텍스트와 상호작용할 수 있도록 공식적인 API를 열어둔 것
- ACL(안티코럽션 계층) : 외부 시스템을 사용할 때, 내 도메인이 오염되지 않도록 중간에 번역 계층(Translator/Adapter) 을 두는 것