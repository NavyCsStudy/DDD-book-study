## 9.1 도메인 모델과 경계
도메인은 여러 하위 도메인으로 구분된다. 그렇기 때문에 하나의 모델로 여러 하위 도메인을 표현하려 하면 하위 도메인에 맞지 않는 모델을 만들게 된다.
- 카탈로그에서의 상품, 재고 관리에서 상품, 주문에서 상품은 모두 이름만 같고 의미하는 바가 다르다.
  - 카탈로그에서 상품은 이미지, 이름, 가격, 상세 설명과 같은 상품 정보 위주다.
  - 재고 관리에서는 실존하는 개별 객체를 추적하지 위한 목적으로 상품을 사용한다.
  - 카탈로그에서는 물리적으로 한 개인 상품이 재고 관리에서는 여러개가 된다.

- 반면 논리적으로 같은 존재이지만 도메인에 따라 다른 용어를 사용하는 경우도 있다.
  - 회원 도메인에서는 사용자를 회원이라고 부른다.
  - 주문 도메인에서는 주문자라 부를 수 있다.
<img width="561" height="237" alt="스크린샷 2025-08-04 오후 8 57 49" src="https://github.com/user-attachments/assets/73257714-ce0c-4ff4-8b0f-1e6c1da4dcdd" />

이처럼 같은 대상이라도 부르는 이름이 다르고, 다른 대상이라도 부르는 이름이 같은 수 있다. 그렇기 때문에 하나의 모델로 모든 하위 도메인을 표현하는 시도는 올바르지 않으며 표현할 수도 없다.

올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다. 각 모델은 명시적으로 구분되는 경계를 가져 섞이지 않도록 해야 한다. 여러 하위 도메인 모델이 섞이기 시작하면 모델의 의미가 약해지고 얽히게 되고 각 하위 도메인별로 다르게 발전하는 요구사항을 반영하기 어려워진다.

모델은 특정한 문맥(컨텍스트) 하에서 완전한 의미를 가진다. 이렇게 **구분되는 경계를 갖는 컨텍스트**를 바운디드 컨텍스트(Bounded Context)라고 부른다.


## 9.2 바운디드 컨텍스트

- 바운디드 컨텍스트는 모델의 경계를 결정하며 논리적으로 한 개의 모델을 갖는다. 
- 바운디드 컨텐스트는 용어를 기준으로 구분한다. 
- 바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스템이다. 
- 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.
- 바운디드 컨텍스트는 기업의 팀 조직 구조에 따라 결정되기도 한다.
	- 주문 하위 도메인이라도 주문 팀과 결제 팀이 따로 있을 수 있다.
	- 이 경우 주문 하위 도메인 안에 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트가 존재하게 된다.
<br/>

다음과 같이 용어가 명확하게 구분되지 않아 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.
<img width="653" height="291" alt="스크린샷 2025-08-05 오후 9 00 54" src="https://github.com/user-attachments/assets/cb07332b-0b36-4b6d-a910-18390eac03ec" />

규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현할 때도 있다.

여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는 것이다. 
- 하나의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 한다.
- 이로써 모델이 서로 뒤섞이지 않고 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.
<img width="672" height="248" alt="스크린샷 2025-08-05 오후 9 02 47" src="https://github.com/user-attachments/assets/6839be4e-6c0a-41af-b5c2-014bc4266604" />

바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되며 구현하는 하위 도메인에 알맞은 모델을 포함한다. 
- 같은 상품이더라도 카탈로그의 Product와 재고의 Product는 컨텍스트에 맞는 모델을 갖는다.
- 서로 연관관계도 다르게 맺을 것이다.
<img width="547" height="283" alt="스크린샷 2025-08-05 오후 9 04 14" src="https://github.com/user-attachments/assets/d1b9d978-62ee-4932-aea5-a3ad30ea03bd" />

## 9.3 바운디드 컨텍스트 구현
바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현, 응용, 인프라스트럭처 영역을 모두 포함한다. 도메인 모델의 데이터 구조가 바뀌면 테이블 스키마도 함께 변경해야하므로 테이블도 바운디드 컨텍스트에 포함된다.
<img width="553" height="384" alt="스크린샷 2025-08-05 오후 9 05 25" src="https://github.com/user-attachments/assets/e37d8307-3e16-4afb-b6e5-41b0fd893ea7" />

모든 바운디드 컨텍스트를 도메인 주도로 개발할 필요는 없다. dao와 데이터 중심의 밸류 객체를 이용해서 리뷰 기능을 구현해도 기능을 유지 보수하는 데 큰 문제가 없다.
<img width="532" height="379" alt="스크린샷 2025-08-05 오후 9 06 16" src="https://github.com/user-attachments/assets/bd7adffc-ab35-4251-bf68-71b24ca05224" />

서비스-DAO 구조를 사용하면 도메인 기능이 서비스에 흩어진다. 하지만 기능 자체가 단순하면 유지 보수하는데 문제가 되지 않을 것이다.

하나의 바운디드 컨텍스트에서 두 방식을 혼합할 수도 있다. 대표적인 것이 cqrs 패턴이다. 이를 단일 바운디드 컨텍스트에 적용하면 상태 변경은 도메인 모델 기반으로, 조회는 서비스-DAO를 이용해서 구현할 수 있다.
<img width="508" height="381" alt="스크린샷 2025-08-05 오후 9 07 43" src="https://github.com/user-attachments/assets/f3dac2f7-1b17-4fb0-985d-568b9e8b31d2" />

각각의 바운디드 컨텍스트가 다른 기술을 사용할 수도 있다. 다음처럼 바운디드 컨텍스트가 ui를 가지고 있거나 단순히 json으로 데이터를 내려줄 수도 있다. 그도 아니면 별도의 ui 서버에서 브라우저에 필요한 응답을 제공할 수도 있다.
<img width="519" height="205" alt="스크린샷 2025-08-05 오후 9 09 40" src="https://github.com/user-attachments/assets/a9511643-d034-40db-a333-cfb9ab5d3db9" />

<img width="575" height="202" alt="스크린샷 2025-08-05 오후 9 10 01" src="https://github.com/user-attachments/assets/4c7e8e28-255e-4a36-a4c6-8062773f902d" />


## 9.4 바운디드 컨텍스트 간 통합
카탈로그 하위 도메인에서 추천 기능을 도입한다고 해보자. 
- 기존 카탈로그 팀에서 추천 시스템 팀이 새로 생긴다.
- 카탈로그 하위 도메인에는 카탈로그 바운디드 컨텍스트와 추천 바운디드 컨텍스트가 생긴다.
<img width="404" height="195" alt="스크린샷 2025-08-05 오후 9 12 19" src="https://github.com/user-attachments/assets/77983d01-933a-4350-897f-4f6fb134097d" />

두 팀이 관련된 바운디드 컨텍스트를 개발하며 통합이 발생한다.
- 사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.
<br/>

이때 카탈로그 컨텍스트와 추천 컨텍스트의 도메인 모델은 서로 다르다. 
- 추천 시스템
  - 추천 시스템은 상품 번호 대신 아이템 id라는 용어를 사용한다.
  - 상품 상세 정보 대신 추천 순위와 같은 데이터를 담고 있을 것이다.

- 카탈로그 시스템
  - 카탈로그 시스템에서는 추천 시스템에서 데이터를 받아온다.
  - 하지만 추천의 도메인 모델 대신 카탈로그 도메인 모델을 이용해 추천 상품을 표현한다.

```kotlin
/**
* 상품 추천 기능을 표현하는 도메인 서비스
*/
interface ProductRecommendationService {
	fun getRecommendationsOf(id: ProductId): List<Product>
}
```

도메인 서비스의 구현은 인프라 영역에 위치하며 외부 시스템과의 연동, 도메인 모델 변환을 책임진다.
<img width="633" height="447" alt="스크린샷 2025-08-05 오후 9 15 54" src="https://github.com/user-attachments/assets/b8f58aba-74e4-403e-a4e7-972144ae2a2b" />

인프라의 구현은 rest api를 이용해 추천 상품 목록을 로딩한다. api 응답은 추천 시스템 도메인 모델을 기반으로 하기 때문에 카탈로그 도메인 모델과 일치하지 않을 것이다.
```json
[
	{itemId: 'PROD-1000', type: 'PRODUCT', rank: 100}
]
```


인프라 구현은 카탈로그 도메인에 맞는 상품 모델로 변환한다.
```kotlin
class RecommendationSystemClient(
	private val repository: ProductRepository,
): ProductRecommendationService {
	override fun getRecommandationOf(id: ProductId): List<Product> {
		val items = getRecItems(id.value)
		return items.map { toProduct(it) }
	}

	private fun toProduct(item: RecommandationItem): Product {
		...
	}
}
```

모델간의 변환이 복잡하면 다음과 같이 별도의 클래스를 만들고 처리할 수도 있다.
<img width="622" height="210" alt="스크린샷 2025-08-05 오후 9 21 46" src="https://github.com/user-attachments/assets/20566537-f675-470a-a2e1-530d922621c7" />

rest api 호출은 두 바운디드 컨텍스트를 직접 통합하는 방법이다. 간접적으로 통합하는 방법도 있다. 대표적인 것이 메세지 큐이다. 추천 시스템은 상품 조회 이력이나 구매 이력 같은 내역을 메세지 큐를 통해 전달받을 수 있다.
<img width="591" height="143" alt="스크린샷 2025-08-05 오후 9 22 42" src="https://github.com/user-attachments/assets/570671cf-9cac-452b-9bc9-964da7d8f4d2" />

이는 비동기 처리이기 때문에 카탈로그 컨텍스트는 메세지 처리를 기다리지 않고 자신의 처리를 계속한다.

각각의 컨텍스트를 담당하는 팀은 서로 만나서 주고받을 데이터 형식에 대해 합의해야 한다. 메세지 시스템을 카탈로그에서 관리한다면 큐에는 다음과 같은 메세지가 담길 것이다.
<img width="436" height="160" alt="스크린샷 2025-08-05 오후 9 25 35" src="https://github.com/user-attachments/assets/b981dcc2-f114-4cde-aeb4-11d6e88f2be4" />

추천 컨텍스트 관점에서는 다음과 같이 메세지 데이터 구조를 잡을 수 있을 것이다.
<img width="317" height="150" alt="스크린샷 2025-08-05 오후 9 26 04" src="https://github.com/user-attachments/assets/399c86a7-2923-428f-8198-09f294c03dd8" />

- 카탈로그 관점에서 메세지를 전송한다면 추천 시스템은 자신의 모델에 맞게 메세지를 변환해서 처리해야 한다.
- 반대로 추천 시스템을 기준으로 한다면 카탈로그 쪽에서 메세지 변환을 책임져야 한다.

두 컨텍스트를 개발하는 팀은 메세지 큐에 담을 데이터 구조를 협의하게 된다. 이때 그 큐를 누가 제공하느냐에 따라 데이터 구조가 결정된다. 
- 내가 속해 있는 팀은 다른 팀으로부터 큐를 제공받기 때문에 메세지를 변환할 책임이 우리에게 있다.
<br/>

만일 카탈로그 시스템에서 큐를 제공한다면 pub/sub 모델을 따를 것이다. 한쪽에서는 메세지를 게시하고, 다른 쪽에서는 구독한다.
<img width="608" height="195" alt="스크린샷 2025-08-05 오후 9 28 44" src="https://github.com/user-attachments/assets/80b49a3f-8393-4c35-99b0-ffc7b67128c6" />

반대로 추천 시스템에서 큐를 제공한다면 큐를 통해 메세지를 추천 시스템에 전달하는 방식이 된다. 이 경우 비동기로 메세지를 처리한다는 것을 제외하면 사실상 rest api를 사용해서 데이터를 전달하는 것과 차이가 없다.

> msa와 바운디드 컨텍스트
> 바운디드 컨텍스트를 msa로 구현하면 자연스럽게 컨텍스트별로 모델이 분리된다. 코드 수준에서 모델을 분리하면서 두 컨텍스트의 모델이 섞이지 않도록 해준다.
> 별도 프로세스로 개발한 컨텍스트는 독립적으로 배포, 모니터링하면서 확장된다. 이 또한 msa가 갖는 특징이다.


## 9.5 바운디드 컨텍스트 간 관계
컨텍스트는 어떤 식으로든 연결되기 때문에 다양한 방식으로 관계를 맺는다. 
- 가장 흔한 관계는 한쪽에서 api를 제공하고 다른 쪽에서 api를 호출하는 관계다.
- api를 사용하는 쪽은 api를 제공하는 쪽을 의존하게 된다.
<img width="579" height="128" alt="스크린샷 2025-08-05 오후 9 33 00" src="https://github.com/user-attachments/assets/0c228fec-2681-4e47-85ba-ae941a6d7b55" />

하류(downstream) 컴포넌트인 카탈로그는 상류(upstream) 컴포넌트인 추천의 데이터와 기능에 의존한다. 추천이 제공하는 rest api 인터페이스가 바뀌면 카탈로그의 코드도 바뀌게 된다.

상류 컴포넌트는 일종의 서비스 공급자 역할을 한다. 하류 컴포넌트는 고객의 역할을 한다. 
- 이러한 관계는 두 팀의 상호 협력이 필수적이다.
- 상류 팀이 마음대로 api를 바꾸면 하류 팀은 변경된 api에 맞추느라 우선순위가 높은 다른 기능을 개발하지 못할 수도 있다.
- 반대로 상류 팀이 무언가를 개발할 때마다 하류 팀의 승낙을 받아야한다면 새로운 개발 시도 자체를 하지 않을 수 있다.
- 따라서 두 팀은 서로 개발 계획을 공유하고 일정을 협의해야 한다.
<br/>

상류 컴포넌트는 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다. 
- 하류 컴포넌트가 다수 존재하면 이들의 요구사항을 수용할 수 있는 api를 만들고 이를 서비스 형태로 공개해 서비스 일관성을 유지할 수 있다. 이런 서비스를 공개 호스트 서비스(open host service)라고 한다.
- 대표적인 예가 검색이다. 각종 서비스를 제공하는 포털은 검색을 위한 전용 시스템을 구축하고 검색 시스템과 각 서비스를 통합한다.
<img width="658" height="255" alt="스크린샷 2025-08-06 오후 9 38 59" src="https://github.com/user-attachments/assets/3e3bdc2e-3ee1-4095-a42b-552ca87abcb9" />

상류 컴포너트의 서비스는 상류 컨텍스트의 도메인 모델을 따른다. 
- 따라서 하류 컴포넌트는 상류 서비스 모델이 자신의 도메인 모델에 영향을 주지 않도록 완충 지대를 만들어야 한다.
<img width="688" height="472" alt="스크린샷 2025-08-06 오후 9 40 16" src="https://github.com/user-attachments/assets/390d5c9c-c182-4398-b5f9-c5f49268e994" />

RecSystemClient는 모델이 깨지는 것을 막아주는 안티코럽션 계층이 된다.

두 컨텍스트가 같은 모델을 공유하는 경우도 있다. 
- 주문 관리 도구 개발 팀과 주문 서비스 개발팀은 모델을 공유하여 주문과 관련된 중복 설계를 막을 수 있다. 이러한 모델을 공유 커널(shared kernel)이라고 부른다.
- 공유 커널은 중복을 줄여준다.
- 하지만 두 팀이 공유하는 모델이기 때문에 한 팀에서 임의로 모델을 변경하면 안 되며 두 팀이 밀접한 관계를 유지해야 한다. 두 팀이 밀접한 관계를 형성하지 못하면 개발이 지연되고 정체되는 문제가 더 커진다.
<br/>

마지막 관계는 독립 방식(separate way)이다. 
- 서로 통합하지 않는다.
- 두 컨텍스트는 독립적으로 모델을 발전시킨다.
<br/>

독립 방식에서 컨텍스트 간의 통합은 수동으로 이루어진다. 
- 쇼핑몰 솔루션은 외부 erp 서비스와의 연동을 지원하지 않으므로 운영자가 수동으로 판매 내역을 erp 시스템에 입력해야 한다.
<img width="618" height="120" alt="스크린샷 2025-08-06 오후 9 44 47" src="https://github.com/user-attachments/assets/2f495d12-e5aa-4b68-b5fb-c0773c03c283" />

규모가 커질수록 언젠가는 컨텍스트들을 통합해야 한다. 기존의 시스템을 대체할 수 없다면 컨텍스트를 통합해주는 별도 시스템을 만들어야 할 수 있다.
<img width="637" height="124" alt="스크린샷 2025-08-06 오후 9 45 40" src="https://github.com/user-attachments/assets/20d801e9-1928-47f9-8c1e-353f5f60da1d" />


## 9.6 컨텍스트 맵
개별 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다. 이를 방지하기 위해 전체 비즈니스를 조망할 수 있는 지도가 필요하다. 이를 컨텍스트 맵이라 한다.
<img width="664" height="371" alt="스크린샷 2025-08-06 오후 9 49 50" src="https://github.com/user-attachments/assets/9b506c95-bb5a-492f-bc48-4e6e615b7fa0" />

컨텍스트 영역에 주요 애그리거트를 함께 표시하면 모델에 대한 관계가 더 명확히 드러난다. 
- 오픈 호스트 서비스(OHS)
- 안티코럽션 계층(ACL)
- 하위 도메인
- 조직 구조
<br/>

이들을 함께 표시하면 도메인을 포함한 전체 관계를 이해하는 데 도움이 된다.

컨텍스트 맵은 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 컨텍스트를 조절하고 사업의 핵심 도메인을 위해 조직 역량을 어떤 컨텍스트에 집중할지 파악하는 데 도움을 준다.

컨텍스트 맵을 그리는 규칙은 없다. 어떤 도구를 사용해도 좋다.

> 컨텍스트 맵은 전체 시스템 이해 수준을 보여준다. 시스템을 더 잘 이해하거나 시간이 지나면서 컨텍스트 간 관계가 바뀌면 컨텍스트 맵도 함께 바뀐다.
