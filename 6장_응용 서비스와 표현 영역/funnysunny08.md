## 6.1 표현 영역과 응용 영역

- 도메인이 제 기능을 하기 위해서는 사용자와 도메인을 연결해주는 매개체가 필요하다 → 표현 영역, 응용 영역
- 표현 영영
    - 사용자의 요청 해석
    - 사용자가 실행하고 싶은 기능을 판별하여 해당 기능을 제공하는 응용 서비스 실행
    - 사용자가 전달한 데이터를 응용 서비스가 요구하는 형식으로 변환
    - 응용 서비스의 결과를 알맞은 형식으로 응답
- 응용 영역
    - 실제 사용자가 원하는 기능 제공
- 사용자와 상호 작용은 표현 영역이 처리하기 때문에, 응용 서비스는 표현 영역에 의존하지 않는다.

## 6.2 응용 서비스의 역할

- 응용 서비스는 주로 도메인 간의 흐름을 제어하기 때문에 단순한 형태를 갖는다.
- 응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
    - 코드 중복
    - 코드의 응집성이 떨어진다 → 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치한다는 것은 도멩니 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 의미
- 응용 서비스는 트랜잭션 처리도 담당한다.
    - 도메인의 상태 변경을 트랜잭션으로 처리해야 한다.

## 6.3 응용 서비스의 구현

### 6.3.1 응용 서비스의 크기

- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
    - 장점
        - 동일 로직에 대한 코드 중복 제거 ex) `findMemberById()`
    - 단점
        - 클래스의 크기가 커진다 → 연관성 적은 코드가 함께 위치할 가능성이 높아진다
- 구분되는 기능별로 서비스 클래스 구현
    - 한 클래스에 1~3개의 기능 구현
    - ex) `ChangePasswordServcie`
    - 하지만 중복해서 동일한 코드를 구현할 가능성이 있다
        - 별도 클래스에 로직을 구현해서 방지 → `MemberServiceHelper`

### 6.3.2 응용 서비스의 인터페이스와 클래스

- 인터페이스가 꼭 필요한가?
- 구현 클래스가 여러 개이거나 런타임에 구현 객체를 교체해야 하는 경우에는 유용
- 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택은 아니다
    - 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡해진다.
- TDD에서는 인터페이스가 아니더라도 Mockito와 같은 테스트 도구를 이용해 테스트용 대역 객체를 만들 수 있다.

### 6.3.3 메서드 파라미터와 값 리턴

- 응용 서비스에 데이터로 전달할 요청 파라미터가 2개 이상 존재하면 별도 클래스를 사용해 데이터를 전달하는 것이 편리하다.
    - 스프링 MVC와 같은 웹 프레임워크는 웹 요청 파라미터를 자바 객체로 변환하는 기능 제공
- 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.
    - 응용 서비스에서 애그리거트를 반환하게 되면 도메인 로직을 응용 서비스와 표현 영역 두 군데서 할 수 있게 되어 응집도가 낮아진다.

### 6.3.4 표현 영역에 의존하지 않기

- 응용 서비스의 파라미터 타입을 결정할 때 표현 영역과 관련된 타입을 사용하면 안된다.
    - ex) `HttpServletRequest`, `HttpSession`
- 응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기 어려워지며, 변경시 함께 변경해야 한다.
- 응용 서비스가 표현 영역의 역할을 하는 상황이 발생할 수도..
- 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 말자!

### 6.3.5 트랜잭션 처리

- 트랜잭션을 관리하는 것은 응용 서비스의 중요한 역할
- `@Transactional`
    - 런타입 예외 발생시 자동 롤백

## 6.4 표현 영역

표현 영역의 책임

- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

## 6.5 값 검증

- 값 검증은 표현 영역과 응용 서비스에서 수행할 수 있다.
- 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 받아야 한다.
    - 스프링 MVC는 폼에 입력된 값이 잘못된 경우 에서 메시지를 보여주기 위한 용도로 Errors나 BindingResult를 사용하는데, 코드가 번잡하기도 하고
    - 응용 서비스에서 값을 검사하는 시점에 첫 번째 값이 올바르지 않아 예외가 발생하면 이후의 값에 대해서는 검증을 진행하지 않아 사용자가 폼에 값을 여러 번 입력하게 만들 수도 있다.
- 이런 불편함을 해소하기 위해 응용 서비스에서 에러 코드를 모아 하나의 익셉션으로 발생시키는 방법도 있다.
- 스프링에서 값 검증을 위한 Validator 인터페이스를 별도로 제공 → 코드 간결
- 표현 영역에서 필수 값과 같은 형식을 검사하면 실질적으로 응용 서비스는 ID 중복 여부와 같은 논리적 오류만 검사하면 된다. ⇒ 표현 영역과 응용 서비스가 값 검사를 나눠서 수행
    - 표현 영역: 필수값, 값의 형식, 범위 등 검증
    - 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증

## 6.6 권한 검사

- 권한 검사를 위해 스프링 시큐리티 같은 프레임워크를 사용하기도 하며, 이는 유연하고 확장 가능한 구조를 갖고 있다.
- 권한 검사는 표현 영역, 응용 서비스, 도메인에서 수행할 수 있다.
- 표현 영역: 인증된 사용자인지 아닌지
    - 접근 제어를 하기에 좋은 위치가 서블릿 필터이다.
    - 서블릿 필터에서 사용자의 인증 정보를 생성하고 인증 여부를 검사한다.
    - 인증
- 응용 서비스: URL 만으로 접근 제어를 할 수 없는 경우 메서드 단위로 권한 검사를 수행해야 한다.
    - 스프링 시큐리티는 AOP 를 활용해서 다음과 같이 권한 검사를 수행할 수 있다. (@PreAuthorize 등)
- 개별 도메인 객체 단위로 권한 검사를 해야 하는 경우는 구현이 복잡해진다.
    - ex) 게시글 작성자만 게시글을 삭제할 수 있다 → 게시글 애그리거트 로딩해야 하기 때문에 응용 서비스의 메서드 수준에서 권한 검사가 불가능하다. 직접 권한 검사 로직을 구현해야 한다.
- 스프링 시큐리티와 같은 프레임워크를 확장해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합할 수도 있다.
    - 하지만 도메인 객체 수준의 권한 검사 로직은 도메인별로 다르므로 적용하기 위해서는 프레임워크에 대한 높은 이해가 필요하다.
    - 이게 어렵다면 직접 구현하는 것이 코드 유지 보수에 유리하다.

## 6.7 조회 전용 기능과 응용 서비스

5장에서는 조회 화면을 위한 조회 전용 모델과 DAO를 만드는 내용을 다루었는데 서비스에서 이들 조회 전용 기능을 사용하면 서비스 코드가 다음과 같이 단순히 조회 전용 기능을 호출하는 것으로 끝날 수 있다.

```java
public class OrderListService {
  public List<OrderView> getOrderList(String ordererId) {
    return orderViewDao.selectByOrderer(ordererId);
  }
}
```

- 서비스에서 수행하는 추가적인 로직도 없고 단일 조회 쿼리이기에 트랜잭션이 필요하지도 않다.
    - 이 경우에는 서비스를 만들지 않고 표현 영역에서 바로 호출해도 문제가 없다.
    - 응용 서비스가 사용자 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다.