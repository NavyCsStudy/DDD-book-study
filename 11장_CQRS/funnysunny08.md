## 11.1 단일 모델의 단점

- 주문 내역 조회 기능을 구현하기 위해서는 Order(주문 정보), Product(상품 이름), Member(회원 이름, ID) 애그리거트에서 데이터를 가져와야 한다.
- 식별자를 이용해서 애그리거트를 참조하는 방식을 사용하면 즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.
    - 한 번의 SELECT 쿼리로 필요한 데이터를 읽어올 수 없어 조회 성능에 문제가 생길 수 있다.
    - 식별자가 아닌 직접 참조하는 방식으로 연결해도 즉시 로딩이나 지연 로딩으로 처리해야 하기 때문에 참조 방식에 대한 고민이 생긴다.
- 혹은 JPA의 네이티브 쿼리를 사용해야 할 수도 있다.
- 이런 고민들의 이유는 시스템 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문이다.
    - ORM 기법은 도메인 상태 변경 기능을 구현하는 데 적합하나, 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에는 구현을 복잡하게 만드는 원인이다.

## 11.2 CQRS

- 도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경하지만, 조회 기능에 필요한 데이터를 표시하려면 두 개 이상의 애그리거트가 필요할 때가 많다.
- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 떄문에 단일 모델로 두 종류의 기능을 구현하면 모델이 복잡해진다.
- CQRS: 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴
    - CQRS는 복잡한 도메인에 적합하다.
        - 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 나며, 두 기능을 단일 모델로 처리하면 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해진다.
    - CQRS를 사용하면 각 모델에 맞는 구현 기술, 데이터 저장소를 선택할 수 있다.
        - ex) 명령 모델은 JPA, 조회 모델은 MyBatis
        - ex) 명령 모델은 RDBMS, 조회 모델은 NoSQL
    - 두 데이터 저장소 간 데이터 동기화는 이벤트를 활용해서 처리한다.
        - 명령 모델에서 데이터가 바뀌자마자 변경 내역을 바로 조회 모델에 반영해야 한다면 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화할 수 있다.
        - 특정 시간 안에만 동기화해도 된다면 비동기로 데이터를 전송하면 된다.

### 11.2.1 웹과 CQRS

- 일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다.
- 기본적으로 쿼리를 최적화해서 쿼리 실행 속도 자체를 높이고, 메모리에 조회 데이터를 캐싱해서 응답 속도를 높이거나 조회 전용 저장소를 따로 사용하기도 한다.
- 위와 같이 다양한 기법을 사용하는 것은 결과적으로 CQRS를 적용하는 것과 같은 효과를 만든다.
- 대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용하게 된다. 단지 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐이다.

### 11.2.2 CQRS 장단점

**장점**

- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다.
    - 조회 성능을 위한 코드가 명령 모델에 없기 때문에 도메인 로직을 구현하는 데 집중할 수 있다.
    - 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아진다.
- 조회 성능을 향상시키는 데 유리하다.
    - 캐시 기술, 조회에 특화된 쿼리, 조회 전용 저장소

**단점**

- 구현해야 할 코드가 많다.
- 더 많은 구현 기술이 필요하다.

👉 도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다.

반면에 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지 보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려하자.