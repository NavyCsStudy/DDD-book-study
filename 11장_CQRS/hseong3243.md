## 11.1 단일 모델의 단점
주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 한다.
<img width="338" height="212" alt="스크린샷 2025-08-17 오후 2 44 37" src="https://github.com/user-attachments/assets/45e89e00-7fcf-4255-8430-866830c46a8c" />

식별자를 이용해서 애그리거트를 참조하는 방식은 jpa의 즉시 로딩과 같은 쿼리 최적화 기능을 사용할 수 없다.

애그리거트 간 연관을 직접 참조로 바꾸게 되더라도 조회 화면에 따라 지연 로딩으로 처리하는 것이 나은 곳도 있다. 어쩌면 dbms가 제공하는 전용 기능을 사용하기 위해 jpa의 네이티브 쿼리를 사용해야 할 수도 있다.

객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 orm 기법은 도메인 상태 변경 기능을 구현하는 데는 적합하다. 하지만 여러 애그리거트에서 데이터를 가져와 조회 기능을 구현하기에는 고려할 게 많아서 구현을 복잡하게 만드는 원인이 된다.

이런 구현 복잡도를 낮추는 간단한 방법은 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.

## 11.2 cqrs
시스템이 제공하는 기능은 크게 두 가지로 나눌 수 있다.
- 상태를 변경하는 기능
	- 새로운 주문 생성, 배송지 정보 변경 등
	- 개발자는 현재 저장하고 있는 데이터를 변경하는 방식으로 기능을 구현한다.
- 사용자 입장에서 상태 정보를 조회하는 기능
	- 주문 상세 내역 보기, 회원 정보 보기 등
	- 조회 기능은 필요한 데이터를 읽어와 ui를 통해 보여는 방식으로 구현한다.

도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다. 반면 조회 기능은 필요한 데이터를 표시하려면 두 개 이상의 애그리거트가 필요할 때가 많다.

상태 변경 벙위와 상태 조회 **범위가 일치하지 않기 때문에** 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다. 이처럼 단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위해 사용하는 방법이 cqrs다.

cqrs(Command Query Responsibility Segregation)은 상태를 변경하는 명령(command)을 위한 모델과 상태를 제공하는 조회(query)를 위한 모델을 분리하는 패턴이다.
<img width="604" height="421" alt="스크린샷 2025-08-17 오후 2 51 43" src="https://github.com/user-attachments/assets/c9b99e70-5088-4c8a-9fce-95103f7394d4" />

cqrs는 복잡한 도메인에 적합하다. cqrs를 적용하면 조회 모델을 별도로 만들기 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.
- 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 난다. 두 기능을 단일 모델로 처리하면 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해진다.
- jpa 기반 단일 모델일 때는 통계 값을 빠르게 조회하기 위해 jpa와 관련된 다양한 성능 관련 기능을 모델에 적용해야 한다.

cqrs를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.
<img width="479" height="390" alt="스크린샷 2025-08-17 오후 2 55 03" src="https://github.com/user-attachments/assets/2a6a0b87-6e68-4e06-96c8-7b7bc9267ee3" />

단순히 데이터를 읽어와 조회하는 기능은 응용 로직이 복잡하기 않기 때문에 컨트롤러에서 바로 dao를 실행해도 무방하다. 물론 몇 가지 로직이 추가로 필요하다면 응용 서비스를 두고 로직을 구현하면 된다.

주문 목록을 제공할 때 필요한 정보만 담아서 모델을 설계하면 된다.
<img width="603" height="417" alt="스크린샷 2025-08-17 오후 2 56 01" src="https://github.com/user-attachments/assets/02b1ce49-f3b9-41c9-9292-8a6f01f8228b" />

두 모델이 같은 구현 기술을 사용할 수도 있지만 서로 다른 데이터 저장소를 사용할 수도 있다.
<img width="540" height="406" alt="스크린샷 2025-08-17 오후 2 58 31" src="https://github.com/user-attachments/assets/480ecbb7-2eaa-4545-ab4a-7d391b264dcd" />

두 데이터 저장소 간 데이터 동기화는 이벤트를 활용해서 처리한다. 명령 모델에서 이벤트가 발생하면 조회 모델에 전달해서 변경 내역을 반영하면 된다.

두 모델이 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다. 곧 바로 변경 내역을 반영해야 한다면 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화할 수 있다. 하지만 전반적인 성능이 떨어지는 단점이 있다.

특정 시간 안에만 동기화해도 된다면 비동기로 데이터를 전송하면 된다. 예를 들어 통계 데이터는 1시간 단위에 최근 데이터를 반영해도 문제가 되지 않을 때가 많다.
> cqrs 패턴을 적용하기 위해 사용해야 할 필수 기술이 따로 존재하지는 않는다.

### 11.2.1 웹과 cqrs
일반적인 웹 서비스는 상태 변경보다 조회 요청이 더 많다.

조회 요청을 개선하기 위해 다양한 기법을 적용할 수 있다. 
- 기본적으로 쿼리를 최적화해서 쿼리 실행 속도 자체를 높인다.
- 메모리에 조회 데이터를 캐싱 해서 응답 속도를 높인다.
- 조회 전용 저장소를 따로 사용하기도 한다.

조회 성능을 높이기 위해 다양한 기법을 사용하는 것은 결과적으로 cqrs를 적용하는 것과 같은 효과를 만든다. 조회 전용 모델을 캐시하거나, 조회 속도를 개선하기 위한 쿼리를 최적화하여 필요한 데이터만 읽어오는 것이 그렇다.

대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 cqrs를 적용하게 된다. 단지 명시적으로 명령, 조회 모델을 구분하지 않을 뿐이다. 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하자. 이를 통해 조회 기능 때문에 명령 모델이 복잡해지는 것을 막을 수 있고, 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다.

### 11.2.2 cqrs 장단점
#### 장점
- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다.
	- 조회 성능을 위한 코드가 명령 모델에서 사라진다.
	- 복잡도가 낮아지고 도메인 로직을 구현하는 데 집중할 수 있다.
- 조회 성능 향상에 유리하다.
	- 조회 단위로 캐시 기술을 적용하거나 특화된 쿼리를 마음대로 사용할 수 있다.
	- 조회 전용 저장소를 사용해 처리량을 대폭 늘릴 수도 있다.
	- 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.
<img width="426" height="290" alt="스크린샷 2025-08-17 오후 3 15 04" src="https://github.com/user-attachments/assets/a4e97c9b-badf-4a53-be60-a531df08e8f2" />

#### 단점
- 구현해야 할 코드가 더 많다.
	- 단일 모델의 복잡함과 cqrs 구현 비용을 따져봐야 한다.
	- 복잡한 도메인, 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만든 것이 유지 보수에 유리하다.
	- 반면 단순한 도메인, 트래픽이 많지 않은 서비스라면 조회 전용 모델을 따로 만들 때 얻을 이점이 있는지 따져봐야 한다.
- 더 많은 구현 기술이 필요하다.
	- 서로 다른 저장소를 사용할 수도 있다.
	- 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있다.

이러한 장단점을 고려해서 cqrs 도입 여부를 결정해야 한다. 단순한 도메인이라면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다. 트래픽이 높은 서비스라면 단일 모델을 고집하면서 유지 보수 비용이 오히려 높아질 수 있다. 
