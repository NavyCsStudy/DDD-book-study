## 2.1 네 개의 영역

- 표현 계층
    - 사용자의 요청을 받아 응용 영역에 전달
    - 응용 영역의 처리 결과를 다시 사용자에게 반환
    - (스프링 MVC 프레임워크가 표현 영역을 위한 기술)
- 응용 계층
    - 시스템이 사용자에게 제공해야 할 기능 구현
    - 기능 구현을 위해 도메인 영역의 도메인 모델 사용
    - 로직을 직접 수행하기 보다 도메인 모델에 로직 수행 위임
    - Ex) 주문 등록, 주문 취소, 상품 상세 조회
- 도메인 계층
    - 도메인의 핵심 로직 구현
    - Ex) 배송지 변경, 결제 완료, 주문 총액 계산
- 인프라스트럭처 계층
    - 구현 기술에 대한 것
    - RDBMS 연동, 메시징 큐, 데이터 연동 처리 등

## 2.2 계층 구조 아키텍처

- 계층 구조는 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
- 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다.
    - Ex) 응용 계층은 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 인프라스트럭처 계층에 의존하기도 한다.
- 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프타스트럭처 계층에 종속되는 상황의 문제점
    1. 테스트하기 어렵다. `RuleEngine` 이 완벽하게 동작해야 `CalculateDiscountService` 가 올바르게 동작하는지 확인할 수 있다.
    2. 구현 방식을 변경하기 어렵다.
    
    👉 테스트 어려움, 기능 확장의 어려움
    

## 2.3 DIP

![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs1.png)

- 고수준 모듈: 의미 있는 단일 기능 제공
    - CalculateDiscountService - 가격 할인 계산
- 저수준 모듈: 고수준 모듈이 필요로 하는 하위 기능을 실제로 구현한 것
- 고수준 모듈이 동작하기 위해서는 저수준 모듈을 사용해야 하지만 테스트, 확장 어려움이 있기 때문에 DIP를 활용해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 👉 추상화한 인터페이스를 통해

```java
public interface RuleDiscounter {
		Money applyRules(Customer customer, List<OrderLine> orderLines);
}		
```

```java
public class CalculateDiscountService {
		private RuleDiscounter ruleDiscounter;
    
    public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
	    	this.ruleDiscounter = ruleDiscounter
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
	    	Customer customer = findCustomer(customerId);
	      return ruleDiscounter.applyRules(customer, orderLines);
    }
} 
```

- `CalculateDiscountService` 에는 Drools에 의존하는 코드가 사라지고 RuleDiscounter가 룰을 적용한다는 사실만 알게 되었다.
- `CalculateDiscountService` 는 ‘룰을 이용한 할인 금액 계산’을 추상화한 `RuleDiscounter` 인터페이스에 의존할 뿐이고, `RuleDiscounter` 는 고수준 모듈의 개념이다.
- DIP
    - 목적: 저수준 모듈이 고수준 모듈에 의존하게 된다.
    - 문제 해결
        - 구현 교체가 어려움 ⇒ 사용할 저수준 구현 객체 변경하면 됨, 고수준 모듈은 변경할 필요가 없음
        - 테스트 어려움 ⇒ 인터페이스이므로 mock 객체를 사용해서 테스트 진행 가능
    - 주의사항
        - 저수준 모듈에서 인터페이스를 추출하지 말 것
            
            ![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs2.png)
            
            ![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs3.png)
            
- DIP와 아키텍처
    - 인프라스트럭처 계층이 가장 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
    - 인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능

## 2.4 도메인 영역의 주요 구성요소

![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs4.png)

### 2.4.1 엔티티와 밸류

- 실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은 것이 아니다.
- 도메인 모델의 엔티티는 **데이터와 함께 기능을 제공하는 객체**이다.
    - 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
- 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다.
    - RDBMS에서는 밸류 타입을 제대로 표현하기 어려움

### 2.4.2 애그리거트

- 애그리거트는 관련 객체를 하나로 묶은 군집
- `주문` ⇒ 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액의 하위 모델로 구성
- 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다.
    - 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
    - 애그리거트 내의 다른 엔티티나 밸류 객체에 접근하기 위해서는 반드시 루트 엔티티를 통해야 하며, 이것은 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.

### 2.4.3 리포지터리

- 도메인 객체를 지속적으로 사용하기 위해 물리적인 저장소에 도메인 객체를 보관해야 하는데, 이를 위한 도메인 모델이 리포지터리 ⇒ 구현을 위한 도메인 모델
- 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 조회, 저장 단위는 애그리거트 루트 → `Order`
    - 애그리거트에 속한 모든 객체를 포함하고 있는 애그리거트 루트 단위로 저장하고 조회
- 리포지토리는 도메인 객체를 영속화하는 데 필요한 기능을 추상화한 것으로 고수준 모듈에 속하며, 기반 기술을 이용해서 리포지토리를 구현한 클래스는 저수준 모듈로 인프라스트럭처 영역에 속한다.

## 2.5 요청 처리 흐름

![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs5.png)

- 표현 영역은 사용자가 전송한 데이터 형식이 올바른지 검사하고 문제가 없다면 데이터를 이용해서 응용 서비스에 기능 실행을 위임한다.
- 표현 영역은 사용자가 전송한 데이터를 응용 서비스가 요구하는 형식으로 변환해서 전달한다.
- 응용 서비스는 도메인 모델을 이용해서 기능을 구현한다.

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원한다
    - 도메인 객체의 영속성 처리, 트랜잭션, SMTP 클라이언트, REST 클라이언트, ..
- DIP에서 언급한 것처럼 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다는 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다
- 하지만 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다.
    - 예를 들어 `@Transactional` 애너테이션을 사용하면 한 줄로 트랜잭션을 처리할 수 있는데 코드에서 스프링에 한 의존을 없애기 위해 더 복잡한 스프링 설정을 사용해야 하는 꼴..

## 2.7 모듈 구성

패키지 구성

![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs6.png)

![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs7.png)

도메인이 크면 하위 도메인 별로 모듈을 나눌 수 있다.

![image.png](/2%EC%9E%A5_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%20%EA%B0%9C%EC%9A%94/image/fs8.png)

도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성할 수 있다.